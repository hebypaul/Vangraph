// Tambo Tools - Spec Operations
import { z } from "zod";
import { 
  getSpecByIssueId,
  getSpecVersionHistory,
  createSpec,
  approveSpec,
  rejectSpec,
  hasApprovedSpec,
} from "@/services/supabase/specs";

// Generate Technical Spec Tool
export const generateTechnicalSpecTool = {
  name: "generateTechnicalSpec",
  description: "Generate a technical specification document for an issue based on its description",
  parameters: z.object({
    issueId: z.string().describe("The issue ID to generate spec for"),
    issueTitle: z.string().describe("The issue title"),
    issueDescription: z.string().describe("The issue description"),
    techStack: z.array(z.string()).optional().describe("Project tech stack"),
  }),
  handler: async ({ issueId, issueTitle, issueDescription, techStack }: {
    issueId: string;
    issueTitle: string;
    issueDescription: string;
    techStack?: string[];
  }) => {
    // Generate spec content (in real implementation, this would use AI)
    const specContent = `# Technical Specification: ${issueTitle}

## Overview
${issueDescription || 'No description provided.'}

## Technical Requirements

### Functional Requirements
- [ ] Implement core functionality as described
- [ ] Handle edge cases and error states
- [ ] Add appropriate logging and monitoring

### Non-Functional Requirements
- [ ] Performance: Response time < 200ms
- [ ] Security: Follow OWASP guidelines
- [ ] Accessibility: WCAG 2.1 AA compliance

## Implementation Approach

### Tech Stack
${techStack?.length ? techStack.map(t => `- ${t}`).join('\n') : '- To be determined'}

### Components Affected
- [ ] Frontend components
- [ ] API endpoints
- [ ] Database schema

## Testing Strategy
- Unit tests for business logic
- Integration tests for API endpoints
- E2E tests for critical user flows

## Risks & Mitigations
| Risk | Mitigation |
|------|------------|
| Scope creep | Clear acceptance criteria |
| Technical debt | Code review process |

## Acceptance Criteria
- [ ] All requirements implemented
- [ ] Tests passing
- [ ] Documentation updated
- [ ] Code reviewed and approved

---
*Generated by Vangraph AI*
`;

    const spec = await createSpec({
      issue_id: issueId,
      markdown_content: specContent,
      architect_id: 'vangraph-ai',
      generation_prompt: `Generate spec for: ${issueTitle}`,
    });

    return {
      success: true,
      spec: {
        id: spec.id,
        version: spec.version,
        is_approved: spec.is_approved,
      },
      message: `Generated spec v${spec.version} for issue. Awaiting approval.`,
    };
  },
};

// Get Spec Tool
export const getSpecTool = {
  name: "getSpec",
  description: "Get the current spec for an issue",
  parameters: z.object({
    issueId: z.string().describe("The issue ID"),
  }),
  handler: async ({ issueId }: { issueId: string }) => {
    const spec = await getSpecByIssueId(issueId);
    
    if (!spec) {
      return {
        success: false,
        hasSpec: false,
        message: "No spec exists for this issue",
      };
    }

    return {
      success: true,
      hasSpec: true,
      spec: {
        id: spec.id,
        version: spec.version,
        is_approved: spec.is_approved,
        approved_at: spec.approved_at,
        content_preview: spec.markdown_content.substring(0, 500) + '...',
      },
    };
  },
};

// Get Spec Version History Tool
export const getSpecVersionHistoryTool = {
  name: "getSpecVersionHistory",
  description: "Get all versions of a spec for an issue",
  parameters: z.object({
    issueId: z.string().describe("The issue ID"),
  }),
  handler: async ({ issueId }: { issueId: string }) => {
    const versions = await getSpecVersionHistory(issueId);
    
    return {
      success: true,
      versions: versions.map(v => ({
        version: v.version,
        is_approved: v.is_approved,
        created_at: v.created_at,
      })),
    };
  },
};

// Approve Spec Tool
export const approveSpecTool = {
  name: "approveSpec",
  description: "Approve a spec, allowing implementation to proceed",
  parameters: z.object({
    specId: z.string().describe("The spec ID to approve"),
    approverId: z.string().describe("The user ID of the approver"),
  }),
  handler: async ({ specId, approverId }: { specId: string; approverId: string }) => {
    const spec = await approveSpec(specId, { approved_by: approverId });
    
    return {
      success: true,
      spec: {
        id: spec.id,
        is_approved: spec.is_approved,
        approved_at: spec.approved_at,
      },
      message: "Spec approved. Implementation can proceed.",
    };
  },
};

// Verify Against Spec Tool
export const verifyAgainstSpecTool = {
  name: "verifyAgainstSpec",
  description: "Check if an issue has an approved spec (governance check)",
  parameters: z.object({
    issueId: z.string().describe("The issue ID to verify"),
  }),
  handler: async ({ issueId }: { issueId: string }) => {
    const approved = await hasApprovedSpec(issueId);
    
    return {
      success: true,
      hasApprovedSpec: approved,
      canProceed: approved,
      message: approved 
        ? "Issue has an approved spec. Implementation can proceed."
        : "Issue does not have an approved spec. Approval required before implementation.",
    };
  },
};
